# 4. 클래스와 객체

## 객체 지향 언어란

- 캡슐화
    - 객체를 캡슐로 싸서 내부를 보호하고 볼 수 없게 하는 것
    - 클래스라는 캡슐을 사용한다
    - public,private,protected( 접근지정자에서 상세내용 설명)
- 상속
    - 자식 클래스가 부모 클래스의 속성을 물려받고 기능을 추가하여 확장하는 개념
    - 부모 클래스  = 슈퍼 클래스 /  자식 클래스 = 서브 클래스
    - 서브 클래스가 슈퍼 클래스의 필드와 메소드를 물려받아 코드를 재사용한다.
- 다형성
    - 같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 동작하도록 구현되는 것
    - 슈퍼클래스에서 구현된 메소드를 자신의 특징에 맞게 다시 구현하는 것(오버라이딩)

## 객체 지향 언어의 목적

- 소프트웨어의 생산성 향상
    - 소프트웨어의 재사용을 위한 여러 기법들을 가진 객체 지향 언어가 만들어짐
    - 이미 작성된 코드를 재사용하기 쉬우며, 부분 수정을 통해 소프트웨어를 다시 만드는 부담을 줄일 수 있음
- 실세계에 대한 쉬운 모델링
    - 예전에는 계산이나 통계 처리 등 데이터 처리 과정의 절차를 잘 표현하는 절차 지향 언어가 적합했지만, 실세계 일을 프로그래밍하는 경우가 늘어남
    - 객체들의 상호 작용으로 묘사하는 것이 더 적합함
    - 객체 지향 개념은 프로그램을 보다 실제 세상에 가깝게 모델링하여 물체를 객체로 표현하고,객체들의 관계,상호 작용을 설계하여 각각 클래스로 표현하면 됨

## 클래스와 객체

- 클래스 구성
    - 필드(멤버 변수)와 메소드(멤버 함수)로 구성됨
    - 클래스 선언 ( class Person )
    - 접근 지정자( public )
    - 생성자(constructor)

## 레퍼런스 변수

- 래퍼런스 변수 선언
    - 객체를 생성하기 전, 객체를 가르킬 레퍼런스 변수를 먼저 선언함

        ex) Circle pizza; // 레퍼런스 변수 pizza 선언

    - 레퍼런스 변수만 생성하여 초기화한 것이지 객체가 생성된 것은 아니다

- 객체 생성,new 연산자 이용
    - 자바에서는 new 연산자를 반드시 사용하여 객체를 생성함

        ex) pizza = new Circle();

    - 객체의 주소를 pizza 변수에 대입함
    - Cirlce 타입 크기의 메모리 할당한 후 Circle() 생성자 코드를 실행한다

- 객체 멤버 접근
    - 객체 레퍼런스.멤버 ( pizza.radius = 10;)

## 생성자

- 생성자(constructor)
    - 객체가 생성될 때 객체의 초기화를 위해 실행되는 메소드
    - 객체가 생성되는 순간에 자동으로 호출됨
    - 생성자 이름은 클래스 이름과 동일
    - 생성자는 여러 개 작성할 수 있다 (오버로딩)

        → 오버로딩이란 매개변수의 개수와 타입이 다른 것

    - 생성자는 리턴 타입이 없다!

```kotlin
public class Circle{
	int radius;
	String name;

	public Circle(){
		radius = 1;
		name = "seungwon";
	}

	public static void main(String[] args){
		Circle donut = new Circle(); // 객체 생성 (반지름 1, 이름 seungwon)
		donut.name = "도넛" // 도넛이름을 도넛으로 변경
		System.out.println(donut.name + "의 반지름은 " + donut.radius);
	}
}
```

## this 레퍼런스

- this의 기초 개념
    - this는 현재 객체 자신에 대한 레퍼런스이다. 즉 현재 실행되고 있는 메소드가 속한 객체에 대한 레퍼런스이다

```kotlin
pulbic class Circle{
	int radius;
	public Circle(int r) { this.radius = r;} // this.radius는 Circle객체의 radius를 가르킴
	public int getRadius() { return radius; } 
}
```

- 현재 객체 = Class Circle

- this의 필요성
    - 매개 변수의 이름과 멤버 변수의 이름이 같을 때 유용하다

```kotlin
public Circle(int radius){this.radius = radius;}
//멤버변수 radius = 매게변수 radius
```

- 메소드가 객체 자신의 레퍼런스를 리턴할 경우 사용

```kotlin
public Circle getMe() { return this;} // getMe()메소드는 객체 자신의 레퍼런스를 리턴
```

## 접근 지정자

- private → default → protected →public
- 패키지
    - 자바는 서로 관련있는 클래스 파일들을 패키지에 저장하여 관리한다
    - 패키지는 디렉터리 혹은 폴더와 같은 개념이다
- public
    - 패키지에 상관없이 다른 어떤 클래스에게도 사용이 허용된다
- default
    - 접근 지정자 없이 클래스를 선언한 경우, 디폴트(default)로 선언된다
    - 같은 패키지내의 클래스들에게만 사용이 허용된다
- pivate
    - 클래스 내의 멤버들에게만 접근이 허용된다
- protected
    - 같은 패키지의 모든 클래스에서 접근이 허용된다
    - 다른 패키지일 경우 자식 클래스의 경우 접근 허용된다

## static 멤버

- static 멤버는 객체를 생성하지 않고 사용할 수 있는 멤버이다
- 클래스당 하나만 생성되는 멤버로서 동일한 클래스의 모든 객체들이 공유한다
- main()메소드가 실행되기 전에 이미 생성됨

## non-static 멤버

- 객체가 생성될 때 생기며 다른 객체들과 공유하지 않는다
- 객체가 사라지면 멤버도 같이 사라지고 접근 불가

## static 활용

- 전역 변수와 전역 함수를 만들 때 활용
- 공유 멤버를 만들고자 할 때 활용
- static 메소드는 static 멤버만 접근 가능
- static 메소드는 this를 사용할 수 없다(객체 생성 이전이므로)

## final

- final이 클래스 이름 앞에 사용되면 상속받을 수 없다(final class FinalClass{})
- final 메소드를 선언하면 오버라이디할 수 없는 메소드이다
- final 필드를 선언하면 상수가 된다